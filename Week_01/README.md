学习笔记

*三数之和*

排序+双指针

1. 对数组进行排序，使用双指针方法需要数组有序
2. 对于排序好的数组，如果当前的数`num[i] > 0`，那么后面不会再有负数使整个和为0，所以直接返回结果
3. 如果相邻元素相同`num[i] == nums[i - 1]`，那么跳过，避免重复解。
4. 设置左右指针，`left = i + `, `right = n - 1`，如果`num[i] + nums[left] + nums[right] == 0`那么把这组数放到结果数组里。
    1. 左指针向右跳过相同的数
    2. 右指针向左跳过相同的数
5. 如果和小于零，则将左指针向右移动一位
6. 如果和大于零，则将右指针向左移动一位

时间复杂度$O(n^2)$

*反转链表*

1. 头插法
    利用一个新的头节点，在遍历链表时将头节点的下一个节点指向遍历的当前节点，当前节点的下一个节点指向头节点原来指向的下一个节点，即它的前序节点。
2. 迭代
    设置三个指针，`prev, cur, next`
    `prev`指向逆序后的前序节点，即正序`cur`的下一个节点
    `cur`指向当前遍历的节点，要逆序的第一个节点
    `next`指向要逆序的两个节点后面的第一个节点
3. 递归
    先递归到最后一个节点，即递归的退出条件是遍历到最后一个节点。
    当节点时依次退出栈，此时交换递归返回的值P，与入栈前的head节点的顺序
    递归的调用栈全部退完后，整个链表的顺序也逆过来了。

*两两交换链表中的节点*

1. 递归
    与逆序链别的递归方法类似，递归的结束条件是遍历到最后一个节点。
    新的头节点指向递归调用前的节点的下一个节点，当跳出递归后，原有的头节点可以再指回交换后的新头节点
2. 迭代
    遍历链表，交换两个节点

*环形链表*

1. 哈希表
    表中存链表遍历的元素值，如果访问到表中存在的值则链表有环。
    时间复杂度$O(n)$，空间复杂度$O(n)$
2. 快慢指针
    让快指针比慢指针先走一步，如果有环则快指针一定会与慢指针再次相遇。

*环形链表II*
1. 哈希表，同上
2. 快慢指针
    与上题类似，当快慢指针相遇时，让一个指针指向链表头节点，并与慢指针一起向后走，当他们相遇时就是入环点。

*K个一组翻转链表*
1. 首先设置一个新的头节点，以及`prev, tail`指针
2. 让tail指针向后走K个节点
3. 用临时节点指向第K个节点的下一个节点，用于在逆序后重新拼接链表
4. 将`head, tail`范围内的链表逆序
5. 令新的`tail.next`指向之前保存的临时节点
6. `prev.next`指向新的`head`节点
7. 将`prev`重新指向第$K$个节点，`head`指向第$K+1$个节点

**接雨水**

双指针法
在两端各设置一个指针，并使用两个变量保存指针遍历过程中找到的最高的条形块高度
在最高的条形块内计算可存的雨水量
```
1. 初始化指针
while left < right: 
    if left_height < right_height:
       if left_height >= left_max: 
           update left_max
       else: 
           ans += left_max - left_height
       left++
    else:
        if right_height > right_max:
            update right_max
        else:
            ans += right_max - right_height
        right++
```